# 虚拟内存设计

从代码上来讲, 就是两层的设计方式.

第一层, 使用 page 这个 structure 来控制物理磁盘的 allocate.   
第二层, 虚拟地址层, 使用 mm\_struct + vma\_struct 来进行控制.这个地方, vma 和 mm 为什么需要两个?因为物理地址是连续的, 而 vma 则是离散的.

但是, 这三个 struct 都是使用统一的一个链表来进行控制的. 也就是 list.h 当中的 list\_entry / list\_entry\_t;  

所以, 使用 page 这个 structure 的时候, 只需要考虑内存的规划, 内存的分区, 内存的申请以及释放,还有快表的使用.   
这个代码当中, 转换虚拟内存地址, get\_ptg 行为也放在物理内存的管理当中.  

而 vmm 这个, 涉及到的是, 需要管理申请的内存如何与磁盘空间进行交换.所以涉及到 swap.c 这个定义.但是这个 swap , 只是负责 swap 这个行为, 并不负责初始化 swap 的这个空间.  
初始化空间的行为, 是放在了 fs 去进行管理的. 而 fs 里面, 则调用了 ide, 也就是磁盘的驱动.   

> 思考一个问题, 一旦发生 page fault ,我们需要做什么? 什么是缺页异常? 也就是说, 我要找的页面不在内存里面, 我需要去磁盘里面找.
> struct mm\_struct *mm, uint32\_t error\_code, uintptr\_t addr
> 上面的参数当中, 一个是 mm\_struct 这个是一个虚拟地址, 所以,就是在访问 mm 当中的 addr 的时候, 发生了缺页异常. 我们需要说, 找到目前这个地址真实存在的地址.
> 然后,我们根据这个地址, 把它 swap in 进来.
> 但是 swap in 进来的话, 肯定是需要把一个东西 swap out 出去. 这个时候就会涉及到一个置换的算法问题.
> 而在没有执行 swap in & out 之前,我们需要找到这个物理页面, 那么, 这个物理页面存储在什么位置? 我们需要去页表里面找到
> 按照这个推断的话,  mm 里面肯定存储这这个页面是否需要触发缺页行为的 bit 位. 在哪里?
> https://chyyuu.gitbooks.io/ucore\_os\_docs/content/lab3/lab3\_4\_page\_fault\_handler.html
> 这个地方完美的解决了我的问题. present bit 位, 就是用来描述说, 页面是否在内存当中, 如果不在, 咱们开始 swap.
> 所以, 缺页, 是在物理地址上找不到了, 因为物理地址, 就是内存条.
